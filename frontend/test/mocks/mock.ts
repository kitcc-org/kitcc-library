/**
 * Generated by orval v7.3.0 üç∫
 * Do not edit manually.
 * KITCC Library API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  BadRequestResponse,
  CreateBookBody,
  CreateUserBody,
  DeleteBooksBody,
  DeleteUsersBody,
  Error,
  GetBooksParams,
  GetLoansParams,
  GetUsersParams,
  InternalServerErrorResponse,
  LoginBody,
  NotFoundResponse,
  SearchGoogleBooksParams,
  UnauthorizedResponse,
  UpdateBookBody,
  UpdateUserBody,
  UpsertLoans404,
  UpsertLoans409,
  UpsertLoansBodyItem
} from './model'
import {
  faker
} from '@faker-js/faker'
import {
  HttpResponse,
  http
} from 'msw'
import type {
  Book,
  DeleteUser204,
  GetBooks200,
  GetLoans200,
  GetUsers200,
  GoogleBook,
  Loan,
  SearchGoogleBooks200,
  User
} from './model'


type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;



/**
 * „Éö„Éº„Ç∏Áï™Âè∑„ÅåÊåáÂÆö„Åï„Çå„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅØ1„Éö„Éº„Ç∏ÁõÆ„ÇíËøî„Åô
 * @summary Êõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getBooksResponse = {
  data: GetBooks200;
  status: number;
  headers: Headers;
}

export const getGetBooksUrl = (params?: GetBooksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `https://localhost:8787/books?${normalizedParams.toString()}` : `https://localhost:8787/books`
}

export const getBooks = async (params?: GetBooksParams, options?: RequestInit): Promise<getBooksResponse> => {
  
  const res = await fetch(getGetBooksUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}



export const getGetBooksQueryKey = (params?: GetBooksParams,) => {
    return [`https://localhost:8787/books`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBooksQueryOptions = <TData = Awaited<ReturnType<typeof getBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(params?: GetBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBooks>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBooksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBooks>>> = ({ signal }) => getBooks(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBooks>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBooksQueryResult = NonNullable<Awaited<ReturnType<typeof getBooks>>>
export type GetBooksQueryError = BadRequestResponse | InternalServerErrorResponse


/**
 * @summary Êõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetBooks<TData = Awaited<ReturnType<typeof getBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(
 params?: GetBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBooks>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetBooksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Êõ∏Á±ç„ÇíËøΩÂä†„Åô„Çã
 */
export type createBookResponse = {
  data: Book;
  status: number;
  headers: Headers;
}

export const getCreateBookUrl = () => {


  return `https://localhost:8787/books`
}

export const createBook = async (createBookBody: CreateBookBody, options?: RequestInit): Promise<createBookResponse> => {
  
  const res = await fetch(getCreateBookUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createBookBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getCreateBookMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBook>>, TError,{data: CreateBookBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createBook>>, TError,{data: CreateBookBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBook>>, {data: CreateBookBody}> = (props) => {
          const {data} = props ?? {};

          return  createBook(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBookMutationResult = NonNullable<Awaited<ReturnType<typeof createBook>>>
    export type CreateBookMutationBody = CreateBookBody
    export type CreateBookMutationError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse

    /**
 * @summary Êõ∏Á±ç„ÇíËøΩÂä†„Åô„Çã
 */
export const useCreateBook = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBook>>, TError,{data: CreateBookBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof createBook>>,
        TError,
        {data: CreateBookBody},
        TContext
      > => {

      const mutationOptions = getCreateBookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÊåáÂÆö„Åï„Çå„Åü1ÂÜä‰ª•‰∏ä„ÅÆÊõ∏Á±ç„ÇíÂâäÈô§„Åô„Çã
 */
export type deleteBooksResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getDeleteBooksUrl = () => {


  return `https://localhost:8787/books`
}

export const deleteBooks = async (deleteBooksBody: DeleteBooksBody, options?: RequestInit): Promise<deleteBooksResponse> => {
  
  const res = await fetch(getDeleteBooksUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteBooksBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getDeleteBooksMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBooks>>, TError,{data: DeleteBooksBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBooks>>, TError,{data: DeleteBooksBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBooks>>, {data: DeleteBooksBody}> = (props) => {
          const {data} = props ?? {};

          return  deleteBooks(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBooksMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBooks>>>
    export type DeleteBooksMutationBody = DeleteBooksBody
    export type DeleteBooksMutationError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse

    /**
 * @summary ÊåáÂÆö„Åï„Çå„Åü1ÂÜä‰ª•‰∏ä„ÅÆÊõ∏Á±ç„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteBooks = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBooks>>, TError,{data: DeleteBooksBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBooks>>,
        TError,
        {data: DeleteBooksBody},
        TContext
      > => {

      const mutationOptions = getDeleteBooksMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getBookResponse = {
  data: Book;
  status: number;
  headers: Headers;
}

export const getGetBookUrl = (bookId: string,) => {


  return `https://localhost:8787/books/${bookId}`
}

export const getBook = async (bookId: string, options?: RequestInit): Promise<getBookResponse> => {
  
  const res = await fetch(getGetBookUrl(bookId),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}



export const getGetBookQueryKey = (bookId: string,) => {
    return [`https://localhost:8787/books/${bookId}`] as const;
    }

    
export const getGetBookQueryOptions = <TData = Awaited<ReturnType<typeof getBook>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(bookId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBook>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBookQueryKey(bookId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBook>>> = ({ signal }) => getBook(bookId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(bookId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBook>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBookQueryResult = NonNullable<Awaited<ReturnType<typeof getBook>>>
export type GetBookQueryError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse


/**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetBook<TData = Awaited<ReturnType<typeof getBook>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(
 bookId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBook>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetBookQueryOptions(bookId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * „É™„ÇØ„Ç®„Çπ„Éà„Éú„Éá„Ç£„ÅßÊåáÂÆö„Åï„Çå„ÅüÊÉÖÂ†±„ÅÆ„ÅøÊõ¥Êñ∞„Åô„ÇãÔºé Êõ∏Á±ç„ÅåÁôªÈå≤Ê∏à„Åø„ÅÆÂ†¥Âêà„ÅØËîµÊõ∏Êï∞„Çí+1„Åô„ÇãÔºé

 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export type updateBookResponse = {
  data: Book;
  status: number;
  headers: Headers;
}

export const getUpdateBookUrl = (bookId: string,) => {


  return `https://localhost:8787/books/${bookId}`
}

export const updateBook = async (bookId: string,
    updateBookBody: UpdateBookBody, options?: RequestInit): Promise<updateBookResponse> => {
  
  const res = await fetch(getUpdateBookUrl(bookId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateBookBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getUpdateBookMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBook>>, TError,{bookId: string;data: UpdateBookBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateBook>>, TError,{bookId: string;data: UpdateBookBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBook>>, {bookId: string;data: UpdateBookBody}> = (props) => {
          const {bookId,data} = props ?? {};

          return  updateBook(bookId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBookMutationResult = NonNullable<Awaited<ReturnType<typeof updateBook>>>
    export type UpdateBookMutationBody = UpdateBookBody
    export type UpdateBookMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export const useUpdateBook = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBook>>, TError,{bookId: string;data: UpdateBookBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof updateBook>>,
        TError,
        {bookId: string;data: UpdateBookBody},
        TContext
      > => {

      const mutationOptions = getUpdateBookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÇíÂâäÈô§„Åô„Çã
 */
export type deleteBookResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getDeleteBookUrl = (bookId: string,) => {


  return `https://localhost:8787/books/${bookId}`
}

export const deleteBook = async (bookId: string, options?: RequestInit): Promise<deleteBookResponse> => {
  
  const res = await fetch(getDeleteBookUrl(bookId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getDeleteBookMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBook>>, TError,{bookId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBook>>, TError,{bookId: string}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBook>>, {bookId: string}> = (props) => {
          const {bookId} = props ?? {};

          return  deleteBook(bookId,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBookMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBook>>>
    
    export type DeleteBookMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteBook = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBook>>, TError,{bookId: string}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBook>>,
        TError,
        {bookId: string},
        TContext
      > => {

      const mutationOptions = getDeleteBookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Google Books „Åã„ÇâÊõ∏Á±ç„ÇíÊ§úÁ¥¢„Åô„Çã
 */
export type searchGoogleBooksResponse = {
  data: SearchGoogleBooks200;
  status: number;
  headers: Headers;
}

export const getSearchGoogleBooksUrl = (params?: SearchGoogleBooksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `https://localhost:8787/googlebooks?${normalizedParams.toString()}` : `https://localhost:8787/googlebooks`
}

export const searchGoogleBooks = async (params?: SearchGoogleBooksParams, options?: RequestInit): Promise<searchGoogleBooksResponse> => {
  
  const res = await fetch(getSearchGoogleBooksUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}



export const getSearchGoogleBooksQueryKey = (params?: SearchGoogleBooksParams,) => {
    return [`https://localhost:8787/googlebooks`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchGoogleBooksQueryOptions = <TData = Awaited<ReturnType<typeof searchGoogleBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(params?: SearchGoogleBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchGoogleBooks>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchGoogleBooksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchGoogleBooks>>> = ({ signal }) => searchGoogleBooks(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchGoogleBooks>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchGoogleBooksQueryResult = NonNullable<Awaited<ReturnType<typeof searchGoogleBooks>>>
export type SearchGoogleBooksQueryError = BadRequestResponse | InternalServerErrorResponse


/**
 * @summary Google Books „Åã„ÇâÊõ∏Á±ç„ÇíÊ§úÁ¥¢„Åô„Çã
 */

export function useSearchGoogleBooks<TData = Awaited<ReturnType<typeof searchGoogleBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(
 params?: SearchGoogleBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchGoogleBooks>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchGoogleBooksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Google Books „Åã„ÇâÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getGoogleBookResponse = {
  data: GoogleBook;
  status: number;
  headers: Headers;
}

export const getGetGoogleBookUrl = (volumeId: string,) => {


  return `https://localhost:8787/googlebooks/${volumeId}`
}

export const getGoogleBook = async (volumeId: string, options?: RequestInit): Promise<getGoogleBookResponse> => {
  
  const res = await fetch(getGetGoogleBookUrl(volumeId),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}



export const getGetGoogleBookQueryKey = (volumeId: string,) => {
    return [`https://localhost:8787/googlebooks/${volumeId}`] as const;
    }

    
export const getGetGoogleBookQueryOptions = <TData = Awaited<ReturnType<typeof getGoogleBook>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(volumeId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGoogleBook>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGoogleBookQueryKey(volumeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGoogleBook>>> = ({ signal }) => getGoogleBook(volumeId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(volumeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGoogleBook>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGoogleBookQueryResult = NonNullable<Awaited<ReturnType<typeof getGoogleBook>>>
export type GetGoogleBookQueryError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse


/**
 * @summary Google Books „Åã„ÇâÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetGoogleBook<TData = Awaited<ReturnType<typeof getGoogleBook>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(
 volumeId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGoogleBook>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetGoogleBookQueryOptions(volumeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * „Éö„Éº„Ç∏Áï™Âè∑„ÅåÊåáÂÆö„Åï„Çå„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅØ1„Éö„Éº„Ç∏ÁõÆ„ÇíËøî„Åô
 * @summary „É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getUsersResponse = {
  data: GetUsers200;
  status: number;
  headers: Headers;
}

export const getGetUsersUrl = (params?: GetUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `https://localhost:8787/users?${normalizedParams.toString()}` : `https://localhost:8787/users`
}

export const getUsers = async (params?: GetUsersParams, options?: RequestInit): Promise<getUsersResponse> => {
  
  const res = await fetch(getGetUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}



export const getGetUsersQueryKey = (params?: GetUsersParams,) => {
    return [`https://localhost:8787/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = BadRequestResponse | InternalServerErrorResponse>(params?: GetUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = BadRequestResponse | InternalServerErrorResponse


/**
 * @summary „É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = BadRequestResponse | InternalServerErrorResponse>(
 params?: GetUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary „É¶„Éº„Ç∂„Éº„ÇíËøΩÂä†„Åô„Çã
 */
export type createUserResponse = {
  data: User;
  status: number;
  headers: Headers;
}

export const getCreateUserUrl = () => {


  return `https://localhost:8787/users`
}

export const createUser = async (createUserBody: CreateUserBody, options?: RequestInit): Promise<createUserResponse> => {
  
  const res = await fetch(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getCreateUserMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | Error | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserBody
    export type CreateUserMutationError = BadRequestResponse | UnauthorizedResponse | Error | InternalServerErrorResponse

    /**
 * @summary „É¶„Éº„Ç∂„Éº„ÇíËøΩÂä†„Åô„Çã
 */
export const useCreateUser = <TError = BadRequestResponse | UnauthorizedResponse | Error | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserBody},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÊåáÂÆö„Åï„Çå„Åü1‰∫∫‰ª•‰∏ä„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åô„Çã
 */
export type deleteUsersResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getDeleteUsersUrl = () => {


  return `https://localhost:8787/users`
}

export const deleteUsers = async (deleteUsersBody: DeleteUsersBody, options?: RequestInit): Promise<deleteUsersResponse> => {
  
  const res = await fetch(getDeleteUsersUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteUsersBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getDeleteUsersMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsers>>, TError,{data: DeleteUsersBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUsers>>, TError,{data: DeleteUsersBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUsers>>, {data: DeleteUsersBody}> = (props) => {
          const {data} = props ?? {};

          return  deleteUsers(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUsersMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsers>>>
    export type DeleteUsersMutationBody = DeleteUsersBody
    export type DeleteUsersMutationError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse

    /**
 * @summary ÊåáÂÆö„Åï„Çå„Åü1‰∫∫‰ª•‰∏ä„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteUsers = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsers>>, TError,{data: DeleteUsersBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUsers>>,
        TError,
        {data: DeleteUsersBody},
        TContext
      > => {

      const mutationOptions = getDeleteUsersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getUserResponse = {
  data: User;
  status: number;
  headers: Headers;
}

export const getGetUserUrl = (userId: string,) => {


  return `https://localhost:8787/users/${userId}`
}

export const getUser = async (userId: string, options?: RequestInit): Promise<getUserResponse> => {
  
  const res = await fetch(getGetUserUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}



export const getGetUserQueryKey = (userId: string,) => {
    return [`https://localhost:8787/users/${userId}`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse>(userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse


/**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse>(
 userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * „É™„ÇØ„Ç®„Çπ„Éà„Éú„Éá„Ç£„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„ÇãÊÉÖÂ†±„ÅÆ„ÅøÊõ¥Êñ∞„Åô„Çã
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export type updateUserResponse = {
  data: User;
  status: number;
  headers: Headers;
}

export const getUpdateUserUrl = (userId: string,) => {


  return `https://localhost:8787/users/${userId}`
}

export const updateUser = async (userId: string,
    updateUserBody: UpdateUserBody, options?: RequestInit): Promise<updateUserResponse> => {
  
  const res = await fetch(getUpdateUserUrl(userId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getUpdateUserMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: UpdateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: UpdateUserBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {userId: string;data: UpdateUserBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUser(userId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserBody
    export type UpdateUserMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export const useUpdateUser = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: UpdateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {userId: string;data: UpdateUserBody},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åô„Çã
 */
export type deleteUserResponse = {
  data: DeleteUser204;
  status: number;
  headers: Headers;
}

export const getDeleteUserUrl = (userId: string,) => {


  return `https://localhost:8787/users/${userId}`
}

export const deleteUser = async (userId: string, options?: RequestInit): Promise<deleteUserResponse> => {
  
  const res = await fetch(getDeleteUserUrl(userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getDeleteUserMutationOptions = <TError = BadRequestResponse | Error | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  deleteUser(userId,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = BadRequestResponse | Error | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteUser = <TError = BadRequestResponse | Error | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ÊåáÂÆö„Åï„Çå„ÅüÊù°‰ª∂„Å´ÂêàËá¥„Åô„ÇãË≤∏Âá∫Â±•Ê≠¥„ÇíËøî„Åô
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÂèñÂæó„Åô„Çã
 */
export type getLoansResponse = {
  data: GetLoans200;
  status: number;
  headers: Headers;
}

export const getGetLoansUrl = (params?: GetLoansParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `https://localhost:8787/loans?${normalizedParams.toString()}` : `https://localhost:8787/loans`
}

export const getLoans = async (params?: GetLoansParams, options?: RequestInit): Promise<getLoansResponse> => {
  
  const res = await fetch(getGetLoansUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}



export const getGetLoansQueryKey = (params?: GetLoansParams,) => {
    return [`https://localhost:8787/loans`, ...(params ? [params]: [])] as const;
    }

    
export const getGetLoansQueryOptions = <TData = Awaited<ReturnType<typeof getLoans>>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(params?: GetLoansParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLoans>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLoansQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLoans>>> = ({ signal }) => getLoans(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLoans>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLoansQueryResult = NonNullable<Awaited<ReturnType<typeof getLoans>>>
export type GetLoansQueryError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse


/**
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetLoans<TData = Awaited<ReturnType<typeof getLoans>>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(
 params?: GetLoansParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLoans>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLoansQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export type upsertLoansResponse = {
  data: Loan[];
  status: number;
  headers: Headers;
}

export const getUpsertLoansUrl = () => {


  return `https://localhost:8787/loans`
}

export const upsertLoans = async (upsertLoansBodyItem: UpsertLoansBodyItem[], options?: RequestInit): Promise<upsertLoansResponse> => {
  
  const res = await fetch(getUpsertLoansUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      upsertLoansBodyItem,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getUpsertLoansMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | UpsertLoans404 | UpsertLoans409 | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upsertLoans>>, TError,{data: UpsertLoansBodyItem[]}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof upsertLoans>>, TError,{data: UpsertLoansBodyItem[]}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof upsertLoans>>, {data: UpsertLoansBodyItem[]}> = (props) => {
          const {data} = props ?? {};

          return  upsertLoans(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpsertLoansMutationResult = NonNullable<Awaited<ReturnType<typeof upsertLoans>>>
    export type UpsertLoansMutationBody = UpsertLoansBodyItem[]
    export type UpsertLoansMutationError = BadRequestResponse | UnauthorizedResponse | UpsertLoans404 | UpsertLoans409 | InternalServerErrorResponse

    /**
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export const useUpsertLoans = <TError = BadRequestResponse | UnauthorizedResponse | UpsertLoans404 | UpsertLoans409 | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upsertLoans>>, TError,{data: UpsertLoansBodyItem[]}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof upsertLoans>>,
        TError,
        {data: UpsertLoansBodyItem[]},
        TContext
      > => {

      const mutationOptions = getUpsertLoansMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíCookie„Å´‰øùÂ≠ò„Åô„Çã
 * @summary „É≠„Ç∞„Ç§„É≥„Åô„Çã
 */
export type loginResponse = {
  data: User;
  status: number;
  headers: Headers;
}

export const getLoginUrl = () => {


  return `https://localhost:8787/auth`
}

export const login = async (loginBody: LoginBody, options?: RequestInit): Promise<loginResponse> => {
  
  const res = await fetch(getLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getLoginMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginBody}> = (props) => {
          const {data} = props ?? {};

          return  login(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginBody
    export type LoginMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary „É≠„Ç∞„Ç§„É≥„Åô„Çã
 */
export const useLogin = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginBody},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Cookie„Åã„Çâ„Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÂâäÈô§„Åô„Çã
 * @summary „É≠„Ç∞„Ç¢„Ç¶„Éà„Åô„Çã
 */
export type logoutResponse = {
  data: void;
  status: number;
  headers: Headers;
}

export const getLogoutUrl = () => {


  return `https://localhost:8787/auth`
}

export const logout = async ( options?: RequestInit): Promise<logoutResponse> => {
  
  const res = await fetch(getLogoutUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data, headers: res.headers }
}




export const getLogoutMutationOptions = <TError = InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = InternalServerErrorResponse

    /**
 * @summary „É≠„Ç∞„Ç¢„Ç¶„Éà„Åô„Çã
 */
export const useLogout = <TError = InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    


export const getGetBooksResponseMock = (overrideResponse: Partial< GetBooks200 > = {}): GetBooks200 => ({books: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({authors: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))), description: faker.string.alpha(20), id: faker.number.int({min: undefined, max: undefined}), isbn: faker.helpers.fromRegExp('^\d{10}(\d{3})?$'), publishedDate: faker.date.past().toISOString().split('T')[0], publisher: faker.string.alpha(20), stock: faker.number.int({min: undefined, max: undefined}), thumbnail: faker.helpers.arrayElement([faker.internet.url(), undefined]), title: faker.string.alpha(20)})), totalBook: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getCreateBookResponseMock = (): Book => ({"id":1,"title":"Ë®àÁÆóÊ©ü„Éó„É≠„Ç∞„É©„É†„ÅÆÊßãÈÄ†„Å®Ëß£Èáà","authors":["Harold Abelson","Gerald Jay Sussman","Julie Sussman"],"publisher":"ÁøîÊ≥≥Á§æ","publishedDate":"2012-07-06","description":"Ë®Ä„Çè„Åö„Å®Áü•„Çå„ÅüË®àÁÆóÊ©üÁßëÂ≠¶„ÅÆÂè§ÂÖ∏ÁöÑÂêçËëó","thumbnail":"http://books.google.com/books/content?id=LlH-oAEACAAJ&printsec=frontcover&img=1&zoom=1&source=gbs_api","isbn":"9784798135984","stock":1})

export const getGetBookResponseMock = (): Book => ({"id":1,"title":"Ë®àÁÆóÊ©ü„Éó„É≠„Ç∞„É©„É†„ÅÆÊßãÈÄ†„Å®Ëß£Èáà","authors":["Harold Abelson","Gerald Jay Sussman","Julie Sussman"],"publisher":"ÁøîÊ≥≥Á§æ","publishedDate":"2012-07-06","description":"Ë®Ä„Çè„Åö„Å®Áü•„Çå„ÅüË®àÁÆóÊ©üÁßëÂ≠¶„ÅÆÂè§ÂÖ∏ÁöÑÂêçËëó","thumbnail":"http://books.google.com/books/content?id=LlH-oAEACAAJ&printsec=frontcover&img=1&zoom=1&source=gbs_api","isbn":"9784798135984","stock":1})

export const getUpdateBookResponseMock = (): Book => ({"id":1,"title":"Ë®àÁÆóÊ©ü„Éó„É≠„Ç∞„É©„É†„ÅÆÊßãÈÄ†„Å®Ëß£Èáà","authors":["Harold Abelson","Gerald Jay Sussman","Julie Sussman"],"publisher":"ÁøîÊ≥≥Á§æ","publishedDate":"2012-07-06","description":"Ë®Ä„Çè„Åö„Å®Áü•„Çå„ÅüË®àÁÆóÊ©üÁßëÂ≠¶„ÅÆÂè§ÂÖ∏ÁöÑÂêçËëó","thumbnail":"http://books.google.com/books/content?id=LlH-oAEACAAJ&printsec=frontcover&img=1&zoom=1&source=gbs_api","isbn":"9784798135984","stock":1})

export const getSearchGoogleBooksResponseMock = (overrideResponse: Partial< SearchGoogleBooks200 > = {}): SearchGoogleBooks200 => ({books: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({authors: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))), description: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), id: faker.string.alpha(20), isbn: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), publishedDate: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), publisher: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), thumbnail: faker.helpers.arrayElement([faker.string.alpha(20), undefined]), title: faker.string.alpha(20)})), totalBook: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getGetGoogleBookResponseMock = (): GoogleBook => ({"id":"5-OgzgEACAAJ","title":"Ë®àÁÆóÊ©ü„Éó„É≠„Ç∞„É©„É†„ÅÆÊßãÈÄ†„Å®Ëß£Èáà","authors":["Harold Abelson","Gerald Jay Sussman","Julie Sussman"],"publisher":"ÁøîÊ≥≥Á§æ","publishedDate":"2018-07-01","description":"Ë®Ä„Çè„Åö„Å®Áü•„Çå„ÅüË®àÁÆóÊ©üÁßëÂ≠¶„ÅÆÂè§ÂÖ∏ÁöÑÂêçËëó","thumbnail":"http://books.google.com/books/content?id=LlH-oAEACAAJ&printsec=frontcover&img=1&zoom=1&source=gbs_api","isbn":"9784798135984"})

export const getGetUsersResponseMock = (overrideResponse: Partial< GetUsers200 > = {}): GetUsers200 => ({totalUser: faker.number.int({min: undefined, max: undefined}), users: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({id: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), name: faker.helpers.arrayElement([faker.string.alpha(20), undefined])})), ...overrideResponse})

export const getCreateUserResponseMock = (): User => ({"id":1,"name":"ÊØî‰ºÅË∞∑ÂÖ´Âπ°","email":"hikigaya@oregairu.com","sessionToken":"abcde12345"})

export const getGetUserResponseMock = (): User => ({"id":1,"name":"ÊØî‰ºÅË∞∑ÂÖ´Âπ°","email":"hikigaya@oregairu.com","sessionToken":"abcde12345"})

export const getUpdateUserResponseMock = (): User => ({"id":1,"name":"ÊØî‰ºÅË∞∑ÂÖ´Âπ°","email":"hikigaya@oregairu.com","sessionToken":"abcde12345"})

export const getDeleteUserResponseMock = (): DeleteUser204 => ({"message":"No Content"})

export const getGetLoansResponseMock = (overrideResponse: Partial< GetLoans200 > = {}): GetLoans200 => ({loans: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({books: faker.helpers.arrayElement([{authors: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.string.alpha(20))), description: faker.string.alpha(20), id: faker.number.int({min: undefined, max: undefined}), isbn: faker.helpers.fromRegExp('^\d{10}(\d{3})?$'), publishedDate: faker.date.past().toISOString().split('T')[0], publisher: faker.string.alpha(20), stock: faker.number.int({min: undefined, max: undefined}), thumbnail: faker.helpers.arrayElement([faker.internet.url(), undefined]), title: faker.string.alpha(20)}, undefined]), loans: faker.helpers.arrayElement([{bookId: faker.number.int({min: undefined, max: undefined}), createdAt: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), updatedAt: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), userId: faker.number.int({min: undefined, max: undefined}), volume: faker.number.int({min: undefined, max: undefined})}, undefined]), users: faker.helpers.arrayElement([{email: faker.internet.email(), id: faker.number.int({min: undefined, max: undefined}), name: faker.string.alpha(20), sessionToken: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha(20), null]), undefined])}, undefined])})), totalLoan: faker.number.int({min: undefined, max: undefined}), ...overrideResponse})

export const getUpsertLoansResponseMock = (): Loan[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({bookId: faker.number.int({min: undefined, max: undefined}), createdAt: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), updatedAt: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), userId: faker.number.int({min: undefined, max: undefined}), volume: faker.number.int({min: undefined, max: undefined})})))

export const getLoginResponseMock = (): User => ({"id":1,"name":"ÊØî‰ºÅË∞∑ÂÖ´Âπ°","email":"hikigaya@oregairu.com","sessionToken":"abcde12345"})


export const getGetBooksMockHandler = (overrideResponse?: GetBooks200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetBooks200> | GetBooks200)) => {
  return http.get('*/books', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetBooksResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getCreateBookMockHandler = (overrideResponse?: Book | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<Book> | Book)) => {
  return http.post('*/books', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateBookResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteBooksMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('*/books', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getGetBookMockHandler = (overrideResponse?: Book | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<Book> | Book)) => {
  return http.get('*/books/:bookId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetBookResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getUpdateBookMockHandler = (overrideResponse?: Book | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Book> | Book)) => {
  return http.patch('*/books/:bookId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUpdateBookResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteBookMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('*/books/:bookId', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getSearchGoogleBooksMockHandler = (overrideResponse?: SearchGoogleBooks200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SearchGoogleBooks200> | SearchGoogleBooks200)) => {
  return http.get('*/googlebooks', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getSearchGoogleBooksResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetGoogleBookMockHandler = (overrideResponse?: GoogleBook | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GoogleBook> | GoogleBook)) => {
  return http.get('*/googlebooks/:volumeId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetGoogleBookResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetUsersMockHandler = (overrideResponse?: GetUsers200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetUsers200> | GetUsers200)) => {
  return http.get('*/users', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetUsersResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getCreateUserMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<User> | User)) => {
  return http.post('*/users', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateUserResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteUsersMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('*/users', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}

export const getGetUserMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<User> | User)) => {
  return http.get('*/users/:userId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetUserResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getUpdateUserMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<User> | User)) => {
  return http.patch('*/users/:userId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUpdateUserResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDeleteUserMockHandler = (overrideResponse?: DeleteUser204 | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteUser204> | DeleteUser204)) => {
  return http.delete('*/users/:userId', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDeleteUserResponseMock()),
      { status: 204,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetLoansMockHandler = (overrideResponse?: GetLoans200 | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetLoans200> | GetLoans200)) => {
  return http.get('*/loans', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetLoansResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getUpsertLoansMockHandler = (overrideResponse?: Loan[] | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<Loan[]> | Loan[])) => {
  return http.patch('*/loans', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUpsertLoansResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getLoginMockHandler = (overrideResponse?: User | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<User> | User)) => {
  return http.post('*/auth', async (info) => {
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getLoginResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getLogoutMockHandler = (overrideResponse?: void | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<void> | void)) => {
  return http.delete('*/auth', async (info) => {
  if (typeof overrideResponse === 'function') {await overrideResponse(info); }
    return new HttpResponse(null,
      { status: 204,
        
      })
  })
}
export const getKITCCLibraryAPIMock = () => [
  getGetBooksMockHandler(),
  getCreateBookMockHandler(),
  getDeleteBooksMockHandler(),
  getGetBookMockHandler(),
  getUpdateBookMockHandler(),
  getDeleteBookMockHandler(),
  getSearchGoogleBooksMockHandler(),
  getGetGoogleBookMockHandler(),
  getGetUsersMockHandler(),
  getCreateUserMockHandler(),
  getDeleteUsersMockHandler(),
  getGetUserMockHandler(),
  getUpdateUserMockHandler(),
  getDeleteUserMockHandler(),
  getGetLoansMockHandler(),
  getUpsertLoansMockHandler(),
  getLoginMockHandler(),
  getLogoutMockHandler()
]
