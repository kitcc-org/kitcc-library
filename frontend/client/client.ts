/**
 * Generated by orval v7.2.0 üç∫
 * Do not edit manually.
 * KITCC Library API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  BadRequestResponse,
  Book,
  CreateBookBody,
  CreateUserBody,
  DeleteBooksBody,
  DeleteUser204,
  DeleteUsersBody,
  Error,
  GetBooks200,
  GetBooksParams,
  GetLoans200,
  GetLoansParams,
  GetUsers200,
  GetUsersParams,
  InternalServerErrorResponse,
  Loan,
  LoginBody,
  NotFoundResponse,
  SearchBooks200,
  SearchBooksParams,
  UnauthorizedResponse,
  UpdateBookBody,
  UpdateUserBody,
  UpsertLoans404,
  UpsertLoans409,
  UpsertLoansBodyItem,
  User
} from './client.schemas'
import { customFetch } from './mutator';

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * „Éö„Éº„Ç∏Áï™Âè∑„ÅåÊåáÂÆö„Åï„Çå„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅØ1„Éö„Éº„Ç∏ÁõÆ„ÇíËøî„Åô
 * @summary Êõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getBooksResponse = {
  data: GetBooks200;
  status: number;
}

export const getGetBooksUrl = (params?: GetBooksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `https://localhost:8787/books?${normalizedParams.toString()}` : `https://localhost:8787/books`
}

export const getBooks = async (params?: GetBooksParams, options?: RequestInit): Promise<getBooksResponse> => {
  
  return customFetch<Promise<getBooksResponse>>(getGetBooksUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetBooksQueryKey = (params?: GetBooksParams,) => {
    return [`https://localhost:8787/books`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBooksQueryOptions = <TData = Awaited<ReturnType<typeof getBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(params?: GetBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBooks>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBooksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBooks>>> = ({ signal }) => getBooks(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBooks>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBooksQueryResult = NonNullable<Awaited<ReturnType<typeof getBooks>>>
export type GetBooksQueryError = BadRequestResponse | InternalServerErrorResponse


/**
 * @summary Êõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetBooks<TData = Awaited<ReturnType<typeof getBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(
 params?: GetBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBooks>>, TError, TData>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetBooksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Êõ∏Á±ç„ÇíËøΩÂä†„Åô„Çã
 */
export type createBookResponse = {
  data: Book;
  status: number;
}

export const getCreateBookUrl = () => {


  return `https://localhost:8787/books`
}

export const createBook = async (createBookBody: CreateBookBody, options?: RequestInit): Promise<createBookResponse> => {
  
  return customFetch<Promise<createBookResponse>>(getCreateBookUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createBookBody,)
  }
);}




export const getCreateBookMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBook>>, TError,{data: CreateBookBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createBook>>, TError,{data: CreateBookBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBook>>, {data: CreateBookBody}> = (props) => {
          const {data} = props ?? {};

          return  createBook(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBookMutationResult = NonNullable<Awaited<ReturnType<typeof createBook>>>
    export type CreateBookMutationBody = CreateBookBody
    export type CreateBookMutationError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse

    /**
 * @summary Êõ∏Á±ç„ÇíËøΩÂä†„Åô„Çã
 */
export const useCreateBook = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBook>>, TError,{data: CreateBookBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof createBook>>,
        TError,
        {data: CreateBookBody},
        TContext
      > => {

      const mutationOptions = getCreateBookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÊåáÂÆö„Åï„Çå„Åü1ÂÜä‰ª•‰∏ä„ÅÆÊõ∏Á±ç„ÇíÂâäÈô§„Åô„Çã
 */
export type deleteBooksResponse = {
  data: void;
  status: number;
}

export const getDeleteBooksUrl = () => {


  return `https://localhost:8787/books`
}

export const deleteBooks = async (deleteBooksBody: DeleteBooksBody, options?: RequestInit): Promise<deleteBooksResponse> => {
  
  return customFetch<Promise<deleteBooksResponse>>(getDeleteBooksUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteBooksBody,)
  }
);}




export const getDeleteBooksMutationOptions = <TError = UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBooks>>, TError,{data: DeleteBooksBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBooks>>, TError,{data: DeleteBooksBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBooks>>, {data: DeleteBooksBody}> = (props) => {
          const {data} = props ?? {};

          return  deleteBooks(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBooksMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBooks>>>
    export type DeleteBooksMutationBody = DeleteBooksBody
    export type DeleteBooksMutationError = UnauthorizedResponse | InternalServerErrorResponse

    /**
 * @summary ÊåáÂÆö„Åï„Çå„Åü1ÂÜä‰ª•‰∏ä„ÅÆÊõ∏Á±ç„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteBooks = <TError = UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBooks>>, TError,{data: DeleteBooksBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBooks>>,
        TError,
        {data: DeleteBooksBody},
        TContext
      > => {

      const mutationOptions = getDeleteBooksMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getBookResponse = {
  data: Book;
  status: number;
}

export const getGetBookUrl = (bookId: string,) => {


  return `https://localhost:8787/books/${bookId}`
}

export const getBook = async (bookId: string, options?: RequestInit): Promise<getBookResponse> => {
  
  return customFetch<Promise<getBookResponse>>(getGetBookUrl(bookId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetBookQueryKey = (bookId: string,) => {
    return [`https://localhost:8787/books/${bookId}`] as const;
    }

    
export const getGetBookQueryOptions = <TData = Awaited<ReturnType<typeof getBook>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(bookId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBook>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBookQueryKey(bookId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBook>>> = ({ signal }) => getBook(bookId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(bookId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBook>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBookQueryResult = NonNullable<Awaited<ReturnType<typeof getBook>>>
export type GetBookQueryError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse


/**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetBook<TData = Awaited<ReturnType<typeof getBook>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(
 bookId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBook>>, TError, TData>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetBookQueryOptions(bookId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * „É™„ÇØ„Ç®„Çπ„Éà„Éú„Éá„Ç£„ÅßÊåáÂÆö„Åï„Çå„ÅüÊÉÖÂ†±„ÅÆ„ÅøÊõ¥Êñ∞„Åô„ÇãÔºé Êõ∏Á±ç„ÅåÁôªÈå≤Ê∏à„Åø„ÅÆÂ†¥Âêà„ÅØËîµÊõ∏Êï∞„Çí+1„Åô„ÇãÔºé

 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export type updateBookResponse = {
  data: Book;
  status: number;
}

export const getUpdateBookUrl = (bookId: string,) => {


  return `https://localhost:8787/books/${bookId}`
}

export const updateBook = async (bookId: string,
    updateBookBody: UpdateBookBody, options?: RequestInit): Promise<updateBookResponse> => {
  
  return customFetch<Promise<updateBookResponse>>(getUpdateBookUrl(bookId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateBookBody,)
  }
);}




export const getUpdateBookMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBook>>, TError,{bookId: string;data: UpdateBookBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateBook>>, TError,{bookId: string;data: UpdateBookBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBook>>, {bookId: string;data: UpdateBookBody}> = (props) => {
          const {bookId,data} = props ?? {};

          return  updateBook(bookId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBookMutationResult = NonNullable<Awaited<ReturnType<typeof updateBook>>>
    export type UpdateBookMutationBody = UpdateBookBody
    export type UpdateBookMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export const useUpdateBook = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBook>>, TError,{bookId: string;data: UpdateBookBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateBook>>,
        TError,
        {bookId: string;data: UpdateBookBody},
        TContext
      > => {

      const mutationOptions = getUpdateBookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÇíÂâäÈô§„Åô„Çã
 */
export type deleteBookResponse = {
  data: void;
  status: number;
}

export const getDeleteBookUrl = (bookId: string,) => {


  return `https://localhost:8787/books/${bookId}`
}

export const deleteBook = async (bookId: string, options?: RequestInit): Promise<deleteBookResponse> => {
  
  return customFetch<Promise<deleteBookResponse>>(getDeleteBookUrl(bookId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteBookMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBook>>, TError,{bookId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBook>>, TError,{bookId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBook>>, {bookId: string}> = (props) => {
          const {bookId} = props ?? {};

          return  deleteBook(bookId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBookMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBook>>>
    
    export type DeleteBookMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteBook = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBook>>, TError,{bookId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBook>>,
        TError,
        {bookId: string},
        TContext
      > => {

      const mutationOptions = getDeleteBookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Êõ∏Á±ç„ÇíÊ§úÁ¥¢„Åô„Çã
 */
export type searchBooksResponse = {
  data: SearchBooks200;
  status: number;
}

export const getSearchBooksUrl = (params?: SearchBooksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `https://localhost:8787/books/search?${normalizedParams.toString()}` : `https://localhost:8787/books/search`
}

export const searchBooks = async (params?: SearchBooksParams, options?: RequestInit): Promise<searchBooksResponse> => {
  
  return customFetch<Promise<searchBooksResponse>>(getSearchBooksUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getSearchBooksQueryKey = (params?: SearchBooksParams,) => {
    return [`https://localhost:8787/books/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchBooksQueryOptions = <TData = Awaited<ReturnType<typeof searchBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(params?: SearchBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchBooks>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchBooksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchBooks>>> = ({ signal }) => searchBooks(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchBooks>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchBooksQueryResult = NonNullable<Awaited<ReturnType<typeof searchBooks>>>
export type SearchBooksQueryError = BadRequestResponse | InternalServerErrorResponse


/**
 * @summary Êõ∏Á±ç„ÇíÊ§úÁ¥¢„Åô„Çã
 */

export function useSearchBooks<TData = Awaited<ReturnType<typeof searchBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(
 params?: SearchBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchBooks>>, TError, TData>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchBooksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * „Éö„Éº„Ç∏Áï™Âè∑„ÅåÊåáÂÆö„Åï„Çå„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅØ1„Éö„Éº„Ç∏ÁõÆ„ÇíËøî„Åô
 * @summary „É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getUsersResponse = {
  data: GetUsers200;
  status: number;
}

export const getGetUsersUrl = (params?: GetUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `https://localhost:8787/users?${normalizedParams.toString()}` : `https://localhost:8787/users`
}

export const getUsers = async (params?: GetUsersParams, options?: RequestInit): Promise<getUsersResponse> => {
  
  return customFetch<Promise<getUsersResponse>>(getGetUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetUsersQueryKey = (params?: GetUsersParams,) => {
    return [`https://localhost:8787/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = BadRequestResponse | InternalServerErrorResponse>(params?: GetUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = BadRequestResponse | InternalServerErrorResponse


/**
 * @summary „É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = BadRequestResponse | InternalServerErrorResponse>(
 params?: GetUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary „É¶„Éº„Ç∂„Éº„ÇíËøΩÂä†„Åô„Çã
 */
export type createUserResponse = {
  data: User;
  status: number;
}

export const getCreateUserUrl = () => {


  return `https://localhost:8787/users`
}

export const createUser = async (createUserBody: CreateUserBody, options?: RequestInit): Promise<createUserResponse> => {
  
  return customFetch<Promise<createUserResponse>>(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserBody,)
  }
);}




export const getCreateUserMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | Error | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserBody
    export type CreateUserMutationError = BadRequestResponse | UnauthorizedResponse | Error | InternalServerErrorResponse

    /**
 * @summary „É¶„Éº„Ç∂„Éº„ÇíËøΩÂä†„Åô„Çã
 */
export const useCreateUser = <TError = BadRequestResponse | UnauthorizedResponse | Error | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserBody},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÊåáÂÆö„Åï„Çå„Åü1‰∫∫‰ª•‰∏ä„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åô„Çã
 */
export type deleteUsersResponse = {
  data: void;
  status: number;
}

export const getDeleteUsersUrl = () => {


  return `https://localhost:8787/users`
}

export const deleteUsers = async (deleteUsersBody: DeleteUsersBody, options?: RequestInit): Promise<deleteUsersResponse> => {
  
  return customFetch<Promise<deleteUsersResponse>>(getDeleteUsersUrl(),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      deleteUsersBody,)
  }
);}




export const getDeleteUsersMutationOptions = <TError = UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsers>>, TError,{data: DeleteUsersBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUsers>>, TError,{data: DeleteUsersBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUsers>>, {data: DeleteUsersBody}> = (props) => {
          const {data} = props ?? {};

          return  deleteUsers(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUsersMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsers>>>
    export type DeleteUsersMutationBody = DeleteUsersBody
    export type DeleteUsersMutationError = UnauthorizedResponse | InternalServerErrorResponse

    /**
 * @summary ÊåáÂÆö„Åï„Çå„Åü1‰∫∫‰ª•‰∏ä„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteUsers = <TError = UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsers>>, TError,{data: DeleteUsersBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUsers>>,
        TError,
        {data: DeleteUsersBody},
        TContext
      > => {

      const mutationOptions = getDeleteUsersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getUserResponse = {
  data: User;
  status: number;
}

export const getGetUserUrl = (userId: string,) => {


  return `https://localhost:8787/users/${userId}`
}

export const getUser = async (userId: string, options?: RequestInit): Promise<getUserResponse> => {
  
  return customFetch<Promise<getUserResponse>>(getGetUserUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetUserQueryKey = (userId: string,) => {
    return [`https://localhost:8787/users/${userId}`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse


/**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(
 userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * „É™„ÇØ„Ç®„Çπ„Éà„Éú„Éá„Ç£„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„ÇãÊÉÖÂ†±„ÅÆ„ÅøÊõ¥Êñ∞„Åô„Çã
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export type updateUserResponse = {
  data: User;
  status: number;
}

export const getUpdateUserUrl = (userId: string,) => {


  return `https://localhost:8787/users/${userId}`
}

export const updateUser = async (userId: string,
    updateUserBody: UpdateUserBody, options?: RequestInit): Promise<updateUserResponse> => {
  
  return customFetch<Promise<updateUserResponse>>(getUpdateUserUrl(userId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserBody,)
  }
);}




export const getUpdateUserMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: UpdateUserBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: UpdateUserBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {userId: string;data: UpdateUserBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUser(userId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserBody
    export type UpdateUserMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export const useUpdateUser = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: UpdateUserBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {userId: string;data: UpdateUserBody},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åô„Çã
 */
export type deleteUserResponse = {
  data: DeleteUser204;
  status: number;
}

export const getDeleteUserUrl = (userId: string,) => {


  return `https://localhost:8787/users/${userId}`
}

export const deleteUser = async (userId: string, options?: RequestInit): Promise<deleteUserResponse> => {
  
  return customFetch<Promise<deleteUserResponse>>(getDeleteUserUrl(userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteUserMutationOptions = <TError = BadRequestResponse | Error | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  deleteUser(userId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = BadRequestResponse | Error | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteUser = <TError = BadRequestResponse | Error | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ÊåáÂÆö„Åï„Çå„ÅüÊù°‰ª∂„Å´ÂêàËá¥„Åô„ÇãË≤∏Âá∫Â±•Ê≠¥„ÇíËøî„Åô
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÂèñÂæó„Åô„Çã
 */
export type getLoansResponse = {
  data: GetLoans200;
  status: number;
}

export const getGetLoansUrl = (params?: GetLoansParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `https://localhost:8787/loans?${normalizedParams.toString()}` : `https://localhost:8787/loans`
}

export const getLoans = async (params?: GetLoansParams, options?: RequestInit): Promise<getLoansResponse> => {
  
  return customFetch<Promise<getLoansResponse>>(getGetLoansUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



export const getGetLoansQueryKey = (params?: GetLoansParams,) => {
    return [`https://localhost:8787/loans`, ...(params ? [params]: [])] as const;
    }

    
export const getGetLoansQueryOptions = <TData = Awaited<ReturnType<typeof getLoans>>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(params?: GetLoansParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLoans>>, TError, TData>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLoansQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLoans>>> = ({ signal }) => getLoans(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLoans>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLoansQueryResult = NonNullable<Awaited<ReturnType<typeof getLoans>>>
export type GetLoansQueryError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse


/**
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetLoans<TData = Awaited<ReturnType<typeof getLoans>>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(
 params?: GetLoansParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLoans>>, TError, TData>, request?: SecondParameter<typeof customFetch>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLoansQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export type upsertLoansResponse = {
  data: Loan[];
  status: number;
}

export const getUpsertLoansUrl = () => {


  return `https://localhost:8787/loans`
}

export const upsertLoans = async (upsertLoansBodyItem: UpsertLoansBodyItem[], options?: RequestInit): Promise<upsertLoansResponse> => {
  
  return customFetch<Promise<upsertLoansResponse>>(getUpsertLoansUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      upsertLoansBodyItem,)
  }
);}




export const getUpsertLoansMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | UpsertLoans404 | UpsertLoans409 | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upsertLoans>>, TError,{data: UpsertLoansBodyItem[]}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof upsertLoans>>, TError,{data: UpsertLoansBodyItem[]}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof upsertLoans>>, {data: UpsertLoansBodyItem[]}> = (props) => {
          const {data} = props ?? {};

          return  upsertLoans(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpsertLoansMutationResult = NonNullable<Awaited<ReturnType<typeof upsertLoans>>>
    export type UpsertLoansMutationBody = UpsertLoansBodyItem[]
    export type UpsertLoansMutationError = BadRequestResponse | UnauthorizedResponse | UpsertLoans404 | UpsertLoans409 | InternalServerErrorResponse

    /**
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export const useUpsertLoans = <TError = BadRequestResponse | UnauthorizedResponse | UpsertLoans404 | UpsertLoans409 | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upsertLoans>>, TError,{data: UpsertLoansBodyItem[]}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof upsertLoans>>,
        TError,
        {data: UpsertLoansBodyItem[]},
        TContext
      > => {

      const mutationOptions = getUpsertLoansMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíCookie„Å´‰øùÂ≠ò„Åô„Çã
 * @summary „É≠„Ç∞„Ç§„É≥„Åô„Çã
 */
export type loginResponse = {
  data: User;
  status: number;
}

export const getLoginUrl = () => {


  return `https://localhost:8787/auth`
}

export const login = async (loginBody: LoginBody, options?: RequestInit): Promise<loginResponse> => {
  
  return customFetch<Promise<loginResponse>>(getLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginBody,)
  }
);}




export const getLoginMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginBody}> = (props) => {
          const {data} = props ?? {};

          return  login(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginBody
    export type LoginMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary „É≠„Ç∞„Ç§„É≥„Åô„Çã
 */
export const useLogin = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginBody},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Cookie„Åã„Çâ„Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÂâäÈô§„Åô„Çã
 * @summary „É≠„Ç∞„Ç¢„Ç¶„Éà„Åô„Çã
 */
export type logoutResponse = {
  data: void;
  status: number;
}

export const getLogoutUrl = () => {


  return `https://localhost:8787/auth`
}

export const logout = async ( options?: RequestInit): Promise<logoutResponse> => {
  
  return customFetch<Promise<logoutResponse>>(getLogoutUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getLogoutMutationOptions = <TError = InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = InternalServerErrorResponse

    /**
 * @summary „É≠„Ç∞„Ç¢„Ç¶„Éà„Åô„Çã
 */
export const useLogout = <TError = InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
