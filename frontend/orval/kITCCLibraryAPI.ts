/**
 * Generated by orval v7.1.1 üç∫
 * Do not edit manually.
 * KITCC Library API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  BadRequestResponse,
  Book,
  CreateBookBody,
  CreateLoansBodyItem,
  CreateUser201,
  CreateUserBody,
  DeleteUser204,
  Error,
  GetBooksParams,
  GetLoansParams,
  GetUsersParams,
  InternalServerErrorResponse,
  Loan,
  LoginBody,
  Logout200,
  NotFoundResponse,
  SearchBooks200Item,
  SearchBooksParams,
  UnauthorizedResponse,
  UpdateBookBody,
  UpdateLoansBodyItem,
  UpdateUserBody,
  User
} from './kITCCLibraryAPI.schemas'

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;



/**
 * „Éö„Éº„Ç∏Áï™Âè∑„ÅåÊåáÂÆö„Åï„Çå„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅØ1„Éö„Éº„Ç∏ÁõÆ„ÇíËøî„Åô
 * @summary Êõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getBooksResponse = {
  data: Book[];
  status: number;
}

export const getGetBooksUrl = (params?: GetBooksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:8787/books?${normalizedParams.toString()}` : `http://localhost:8787/books`
}

export const getBooks = async (params?: GetBooksParams, options?: RequestInit): Promise<getBooksResponse> => {
  
  const res = await fetch(getGetBooksUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}



export const getGetBooksQueryKey = (params?: GetBooksParams,) => {
    return [`http://localhost:8787/books`, ...(params ? [params]: [])] as const;
    }

    
export const getGetBooksQueryOptions = <TData = Awaited<ReturnType<typeof getBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(params?: GetBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBooks>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBooksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBooks>>> = ({ signal }) => getBooks(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBooks>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBooksQueryResult = NonNullable<Awaited<ReturnType<typeof getBooks>>>
export type GetBooksQueryError = BadRequestResponse | InternalServerErrorResponse


/**
 * @summary Êõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetBooks<TData = Awaited<ReturnType<typeof getBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(
 params?: GetBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBooks>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetBooksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Êõ∏Á±ç„ÇíËøΩÂä†„Åô„Çã
 */
export type createBookResponse = {
  data: Error;
  status: number;
}

export const getCreateBookUrl = () => {


  return `http://localhost:8787/books`
}

export const createBook = async (createBookBody: CreateBookBody, options?: RequestInit): Promise<createBookResponse> => {
  
  const res = await fetch(getCreateBookUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createBookBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}




export const getCreateBookMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBook>>, TError,{data: CreateBookBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createBook>>, TError,{data: CreateBookBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBook>>, {data: CreateBookBody}> = (props) => {
          const {data} = props ?? {};

          return  createBook(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBookMutationResult = NonNullable<Awaited<ReturnType<typeof createBook>>>
    export type CreateBookMutationBody = CreateBookBody
    export type CreateBookMutationError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse

    /**
 * @summary Êõ∏Á±ç„ÇíËøΩÂä†„Åô„Çã
 */
export const useCreateBook = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBook>>, TError,{data: CreateBookBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof createBook>>,
        TError,
        {data: CreateBookBody},
        TContext
      > => {

      const mutationOptions = getCreateBookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getBookResponse = {
  data: Book;
  status: number;
}

export const getGetBookUrl = (bookId: string,) => {


  return `http://localhost:8787/books/${bookId}`
}

export const getBook = async (bookId: string, options?: RequestInit): Promise<getBookResponse> => {
  
  const res = await fetch(getGetBookUrl(bookId),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}



export const getGetBookQueryKey = (bookId: string,) => {
    return [`http://localhost:8787/books/${bookId}`] as const;
    }

    
export const getGetBookQueryOptions = <TData = Awaited<ReturnType<typeof getBook>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(bookId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBook>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBookQueryKey(bookId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBook>>> = ({ signal }) => getBook(bookId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(bookId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBook>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBookQueryResult = NonNullable<Awaited<ReturnType<typeof getBook>>>
export type GetBookQueryError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse


/**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetBook<TData = Awaited<ReturnType<typeof getBook>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(
 bookId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBook>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetBookQueryOptions(bookId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * „É™„ÇØ„Ç®„Çπ„Éà„Éú„Éá„Ç£„ÅßÊåáÂÆö„Åï„Çå„ÅüÊÉÖÂ†±„ÅÆ„ÅøÊõ¥Êñ∞„Åô„ÇãÔºé Êõ∏Á±ç„ÅåÁôªÈå≤Ê∏à„Åø„ÅÆÂ†¥Âêà„ÅØËîµÊõ∏Êï∞„Çí+1„Åô„ÇãÔºé

 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export type updateBookResponse = {
  data: Book;
  status: number;
}

export const getUpdateBookUrl = (bookId: string,) => {


  return `http://localhost:8787/books/${bookId}`
}

export const updateBook = async (bookId: string,
    updateBookBody: UpdateBookBody, options?: RequestInit): Promise<updateBookResponse> => {
  
  const res = await fetch(getUpdateBookUrl(bookId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateBookBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}




export const getUpdateBookMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBook>>, TError,{bookId: string;data: UpdateBookBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateBook>>, TError,{bookId: string;data: UpdateBookBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBook>>, {bookId: string;data: UpdateBookBody}> = (props) => {
          const {bookId,data} = props ?? {};

          return  updateBook(bookId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBookMutationResult = NonNullable<Awaited<ReturnType<typeof updateBook>>>
    export type UpdateBookMutationBody = UpdateBookBody
    export type UpdateBookMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export const useUpdateBook = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBook>>, TError,{bookId: string;data: UpdateBookBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof updateBook>>,
        TError,
        {bookId: string;data: UpdateBookBody},
        TContext
      > => {

      const mutationOptions = getUpdateBookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÇíÂâäÈô§„Åô„Çã
 */
export type deleteBookResponse = {
  data: void;
  status: number;
}

export const getDeleteBookUrl = (bookId: string,) => {


  return `http://localhost:8787/books/${bookId}`
}

export const deleteBook = async (bookId: string, options?: RequestInit): Promise<deleteBookResponse> => {
  
  const res = await fetch(getDeleteBookUrl(bookId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}




export const getDeleteBookMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBook>>, TError,{bookId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteBook>>, TError,{bookId: string}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBook>>, {bookId: string}> = (props) => {
          const {bookId} = props ?? {};

          return  deleteBook(bookId,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteBookMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBook>>>
    
    export type DeleteBookMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆÊõ∏Á±ç„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteBook = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBook>>, TError,{bookId: string}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteBook>>,
        TError,
        {bookId: string},
        TContext
      > => {

      const mutationOptions = getDeleteBookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Êõ∏Á±ç„ÇíÊ§úÁ¥¢„Åô„Çã
 */
export type searchBooksResponse = {
  data: SearchBooks200Item[];
  status: number;
}

export const getSearchBooksUrl = (params?: SearchBooksParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:8787/books/search?${normalizedParams.toString()}` : `http://localhost:8787/books/search`
}

export const searchBooks = async (params?: SearchBooksParams, options?: RequestInit): Promise<searchBooksResponse> => {
  
  const res = await fetch(getSearchBooksUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}



export const getSearchBooksQueryKey = (params?: SearchBooksParams,) => {
    return [`http://localhost:8787/books/search`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchBooksQueryOptions = <TData = Awaited<ReturnType<typeof searchBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(params?: SearchBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchBooks>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchBooksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchBooks>>> = ({ signal }) => searchBooks(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchBooks>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchBooksQueryResult = NonNullable<Awaited<ReturnType<typeof searchBooks>>>
export type SearchBooksQueryError = BadRequestResponse | InternalServerErrorResponse


/**
 * @summary Êõ∏Á±ç„ÇíÊ§úÁ¥¢„Åô„Çã
 */

export function useSearchBooks<TData = Awaited<ReturnType<typeof searchBooks>>, TError = BadRequestResponse | InternalServerErrorResponse>(
 params?: SearchBooksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchBooks>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchBooksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * „Éö„Éº„Ç∏Áï™Âè∑„ÅåÊåáÂÆö„Åï„Çå„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅØ1„Éö„Éº„Ç∏ÁõÆ„ÇíËøî„Åô
 * @summary „É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getUsersResponse = {
  data: User[];
  status: number;
}

export const getGetUsersUrl = (params?: GetUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:8787/users?${normalizedParams.toString()}` : `http://localhost:8787/users`
}

export const getUsers = async (params?: GetUsersParams, options?: RequestInit): Promise<getUsersResponse> => {
  
  const res = await fetch(getGetUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}



export const getGetUsersQueryKey = (params?: GetUsersParams,) => {
    return [`http://localhost:8787/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = BadRequestResponse | InternalServerErrorResponse>(params?: GetUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = BadRequestResponse | InternalServerErrorResponse


/**
 * @summary „É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetUsers<TData = Awaited<ReturnType<typeof getUsers>>, TError = BadRequestResponse | InternalServerErrorResponse>(
 params?: GetUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary „É¶„Éº„Ç∂„Éº„ÇíËøΩÂä†„Åô„Çã
 */
export type createUserResponse = {
  data: CreateUser201;
  status: number;
}

export const getCreateUserUrl = () => {


  return `http://localhost:8787/users`
}

export const createUser = async (createUserBody: CreateUserBody, options?: RequestInit): Promise<createUserResponse> => {
  
  const res = await fetch(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createUserBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}




export const getCreateUserMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | Error | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserBody
    export type CreateUserMutationError = BadRequestResponse | UnauthorizedResponse | Error | InternalServerErrorResponse

    /**
 * @summary „É¶„Éº„Ç∂„Éº„ÇíËøΩÂä†„Åô„Çã
 */
export const useCreateUser = <TError = BadRequestResponse | UnauthorizedResponse | Error | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserBody},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */
export type getUserResponse = {
  data: User;
  status: number;
}

export const getGetUserUrl = (userId: string,) => {


  return `http://localhost:8787/users/${userId}`
}

export const getUser = async (userId: string, options?: RequestInit): Promise<getUserResponse> => {
  
  const res = await fetch(getGetUserUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}



export const getGetUserQueryKey = (userId: string,) => {
    return [`http://localhost:8787/users/${userId}`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse


/**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse>(
 userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * „É™„ÇØ„Ç®„Çπ„Éà„Éú„Éá„Ç£„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„ÇãÊÉÖÂ†±„ÅÆ„ÅøÊõ¥Êñ∞„Åô„Çã
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export type updateUserResponse = {
  data: User;
  status: number;
}

export const getUpdateUserUrl = (userId: string,) => {


  return `http://localhost:8787/users/${userId}`
}

export const updateUser = async (userId: string,
    updateUserBody: UpdateUserBody, options?: RequestInit): Promise<updateUserResponse> => {
  
  const res = await fetch(getUpdateUserUrl(userId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateUserBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}




export const getUpdateUserMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: UpdateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: UpdateUserBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {userId: string;data: UpdateUserBody}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUser(userId,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserBody
    export type UpdateUserMutationError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÅÆÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export const useUpdateUser = <TError = BadRequestResponse | UnauthorizedResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: UpdateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {userId: string;data: UpdateUserBody},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åô„Çã
 */
export type deleteUserResponse = {
  data: DeleteUser204;
  status: number;
}

export const getDeleteUserUrl = (userId: string,) => {


  return `http://localhost:8787/users/${userId}`
}

export const deleteUser = async (userId: string, options?: RequestInit): Promise<deleteUserResponse> => {
  
  const res = await fetch(getDeleteUserUrl(userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}




export const getDeleteUserMutationOptions = <TError = BadRequestResponse | Error | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  deleteUser(userId,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = BadRequestResponse | Error | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary ÁâπÂÆö„ÅÆ„É¶„Éº„Ç∂„Éº„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteUser = <TError = BadRequestResponse | Error | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ÊåáÂÆö„Åï„Çå„ÅüÊù°‰ª∂„Å´ÂêàËá¥„Åô„ÇãË≤∏Âá∫Â±•Ê≠¥„ÇíËøî„Åô
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÂèñÂæó„Åô„Çã
 */
export type getLoansResponse = {
  data: Loan[];
  status: number;
}

export const getGetLoansUrl = (params?: GetLoansParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  return normalizedParams.size ? `http://localhost:8787/loans?${normalizedParams.toString()}` : `http://localhost:8787/loans`
}

export const getLoans = async (params?: GetLoansParams, options?: RequestInit): Promise<getLoansResponse> => {
  
  const res = await fetch(getGetLoansUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}



export const getGetLoansQueryKey = (params?: GetLoansParams,) => {
    return [`http://localhost:8787/loans`, ...(params ? [params]: [])] as const;
    }

    
export const getGetLoansQueryOptions = <TData = Awaited<ReturnType<typeof getLoans>>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(params?: GetLoansParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLoans>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLoansQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLoans>>> = ({ signal }) => getLoans(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLoans>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLoansQueryResult = NonNullable<Awaited<ReturnType<typeof getLoans>>>
export type GetLoansQueryError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse


/**
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetLoans<TData = Awaited<ReturnType<typeof getLoans>>, TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse>(
 params?: GetLoansParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLoans>>, TError, TData>, fetch?: RequestInit}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLoansQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíËøΩÂä†„Åô„Çã
 */
export type createLoansResponse = {
  data: Loan;
  status: number;
}

export const getCreateLoansUrl = () => {


  return `http://localhost:8787/loans`
}

export const createLoans = async (createLoansBodyItem: CreateLoansBodyItem[], options?: RequestInit): Promise<createLoansResponse> => {
  
  const res = await fetch(getCreateLoansUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createLoansBodyItem,)
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}




export const getCreateLoansMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLoans>>, TError,{data: CreateLoansBodyItem[]}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createLoans>>, TError,{data: CreateLoansBodyItem[]}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createLoans>>, {data: CreateLoansBodyItem[]}> = (props) => {
          const {data} = props ?? {};

          return  createLoans(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateLoansMutationResult = NonNullable<Awaited<ReturnType<typeof createLoans>>>
    export type CreateLoansMutationBody = CreateLoansBodyItem[]
    export type CreateLoansMutationError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse

    /**
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíËøΩÂä†„Åô„Çã
 */
export const useCreateLoans = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLoans>>, TError,{data: CreateLoansBodyItem[]}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof createLoans>>,
        TError,
        {data: CreateLoansBodyItem[]},
        TContext
      > => {

      const mutationOptions = getCreateLoansMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * „É™„ÇØ„Ç®„Çπ„Éà„Éú„Éá„Ç£„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„ÇãÊÉÖÂ†±„ÅÆ„ÅøÊõ¥Êñ∞„Åô„Çã
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export type updateLoansResponse = {
  data: Loan;
  status: number;
}

export const getUpdateLoansUrl = () => {


  return `http://localhost:8787/loans`
}

export const updateLoans = async (updateLoansBodyItem: UpdateLoansBodyItem[], options?: RequestInit): Promise<updateLoansResponse> => {
  
  const res = await fetch(getUpdateLoansUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateLoansBodyItem,)
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}




export const getUpdateLoansMutationOptions = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateLoans>>, TError,{data: UpdateLoansBodyItem[]}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateLoans>>, TError,{data: UpdateLoansBodyItem[]}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateLoans>>, {data: UpdateLoansBodyItem[]}> = (props) => {
          const {data} = props ?? {};

          return  updateLoans(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateLoansMutationResult = NonNullable<Awaited<ReturnType<typeof updateLoans>>>
    export type UpdateLoansMutationBody = UpdateLoansBodyItem[]
    export type UpdateLoansMutationError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse

    /**
 * @summary Ë≤∏Âá∫Â±•Ê≠¥„ÇíÊõ¥Êñ∞„Åô„Çã
 */
export const useUpdateLoans = <TError = BadRequestResponse | UnauthorizedResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateLoans>>, TError,{data: UpdateLoansBodyItem[]}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof updateLoans>>,
        TError,
        {data: UpdateLoansBodyItem[]},
        TContext
      > => {

      const mutationOptions = getUpdateLoansMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * „Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíCookie„Å´‰øùÂ≠ò„Åô„Çã
 * @summary „É≠„Ç∞„Ç§„É≥„Åô„Çã
 */
export type loginResponse = {
  data: User;
  status: number;
}

export const getLoginUrl = () => {


  return `http://localhost:8787/auth`
}

export const login = async (loginBody: LoginBody, options?: RequestInit): Promise<loginResponse> => {
  
  const res = await fetch(getLoginUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginBody,)
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}




export const getLoginMutationOptions = <TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginBody}> = (props) => {
          const {data} = props ?? {};

          return  login(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginBody
    export type LoginMutationError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse

    /**
 * @summary „É≠„Ç∞„Ç§„É≥„Åô„Çã
 */
export const useLogin = <TError = BadRequestResponse | NotFoundResponse | InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginBody},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Cookie„Åã„Çâ„Çª„ÉÉ„Ç∑„Éß„É≥ID„ÇíÂâäÈô§„Åô„Çã
 * @summary „É≠„Ç∞„Ç¢„Ç¶„Éà„Åô„Çã
 */
export type logoutResponse = {
  data: Logout200;
  status: number;
}

export const getLogoutUrl = () => {


  return `http://localhost:8787/auth`
}

export const logout = async ( options?: RequestInit): Promise<logoutResponse> => {
  
  const res = await fetch(getLogoutUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }

  )
  const data = await res.json()

  return { status: res.status, data }
}




export const getLogoutMutationOptions = <TError = InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {
const {mutation: mutationOptions, fetch: fetchOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = InternalServerErrorResponse

    /**
 * @summary „É≠„Ç∞„Ç¢„Ç¶„Éà„Åô„Çã
 */
export const useLogout = <TError = InternalServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
